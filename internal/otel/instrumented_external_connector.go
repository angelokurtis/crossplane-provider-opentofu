// Code generated by gowrap. DO NOT EDIT.
// template: opentelemetry.gotmpl
// gowrap: http://github.com/hexdigest/gowrap

package otel

import (
	"context"
	"path"
	"reflect"

	"github.com/angelokurtis/go-otel/span"
	"github.com/crossplane/crossplane-runtime/v2/pkg/reconciler/managed"
	"github.com/crossplane/crossplane-runtime/v2/pkg/resource"
	"go.opentelemetry.io/otel/attribute"

	semconv "go.opentelemetry.io/otel/semconv/v1.30.0"
)

// InstrumentedExternalConnector implements ExternalConnector interface instrumented with open telemetry spans
type InstrumentedExternalConnector struct {
	ExternalConnector
}

// NewInstrumentedExternalConnector returns InstrumentedExternalConnector
func NewInstrumentedExternalConnector(base ExternalConnector) InstrumentedExternalConnector {
	return InstrumentedExternalConnector{
		ExternalConnector: base,
	}
}

// Connect implements ExternalConnector
func (_d InstrumentedExternalConnector) Connect(ctx context.Context, mg resource.Managed) (e1 managed.ExternalClient, err error) {
	t := reflect.TypeOf(_d.ExternalConnector)
	var pkgPath, pkgName, typeName string
	if t != nil {
		if t.Kind() == reflect.Ptr {
			t = t.Elem() // Dereference pointer to get underlying type
		}
		pkgPath = t.PkgPath()
		pkgName = path.Base(pkgPath)
		typeName = t.Name()
	}
	methodName := "Connect"
	spanName := pkgName + "." + typeName + "." + methodName
	ctx, end := span.StartWithName(ctx, spanName)
	defer func() {
		_ = span.Error(ctx, err)
		end()
	}()

	span.Attributes(ctx,
		semconv.CodeNamespace(pkgPath),
		semconv.CodeFunctionName(methodName),
		attribute.Key("code.type").String(typeName),
	)
	return _d.ExternalConnector.Connect(ctx, mg)
}
