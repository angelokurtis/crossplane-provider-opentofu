// Code generated by gowrap. DO NOT EDIT.
// template: opentelemetry.gotmpl
// gowrap: http://github.com/hexdigest/gowrap

package otel

import (
	"context"
	"reflect"

	"github.com/angelokurtis/go-otel/span"
	"github.com/crossplane/crossplane-runtime/v2/pkg/reconciler/managed"
	"github.com/crossplane/crossplane-runtime/v2/pkg/resource"
	"go.opentelemetry.io/otel/attribute"

	semconv "go.opentelemetry.io/otel/semconv/v1.30.0"
)

// InstrumentedExternalClient implements ExternalClient interface instrumented with open telemetry spans
type InstrumentedExternalClient struct {
	ExternalClient
}

// NewInstrumentedExternalClient returns InstrumentedExternalClient
func NewInstrumentedExternalClient(base ExternalClient) InstrumentedExternalClient {
	return InstrumentedExternalClient{
		ExternalClient: base,
	}
}

// Create implements ExternalClient
func (_d InstrumentedExternalClient) Create(ctx context.Context, mg resource.Managed) (e1 managed.ExternalCreation, err error) {
	t := reflect.TypeOf(_d.ExternalClient)
	var pkgPath, typeName string
	if t != nil {
		if t.Kind() == reflect.Ptr {
			t = t.Elem() // Dereference pointer to get underlying type
		}
		pkgPath = t.PkgPath()
		typeName = t.Name()
	}
	methodName := "Create"
	spanName := pkgPath + "." + typeName + "." + methodName
	ctx, end := span.StartWithName(ctx, spanName)
	defer func() {
		_ = span.Error(ctx, err)
		end()
	}()

	span.Attributes(ctx,
		semconv.CodeNamespace(pkgPath),
		semconv.CodeFunctionName(methodName),
		attribute.Key("code.type").String(typeName),
	)
	return _d.ExternalClient.Create(ctx, mg)
}

// Delete implements ExternalClient
func (_d InstrumentedExternalClient) Delete(ctx context.Context, mg resource.Managed) (e1 managed.ExternalDelete, err error) {
	t := reflect.TypeOf(_d.ExternalClient)
	var pkgPath, typeName string
	if t != nil {
		if t.Kind() == reflect.Ptr {
			t = t.Elem() // Dereference pointer to get underlying type
		}
		pkgPath = t.PkgPath()
		typeName = t.Name()
	}
	methodName := "Delete"
	spanName := pkgPath + "." + typeName + "." + methodName
	ctx, end := span.StartWithName(ctx, spanName)
	defer func() {
		_ = span.Error(ctx, err)
		end()
	}()

	span.Attributes(ctx,
		semconv.CodeNamespace(pkgPath),
		semconv.CodeFunctionName(methodName),
		attribute.Key("code.type").String(typeName),
	)
	return _d.ExternalClient.Delete(ctx, mg)
}

// Disconnect implements ExternalClient
func (_d InstrumentedExternalClient) Disconnect(ctx context.Context) (err error) {
	t := reflect.TypeOf(_d.ExternalClient)
	var pkgPath, typeName string
	if t != nil {
		if t.Kind() == reflect.Ptr {
			t = t.Elem() // Dereference pointer to get underlying type
		}
		pkgPath = t.PkgPath()
		typeName = t.Name()
	}
	methodName := "Disconnect"
	spanName := pkgPath + "." + typeName + "." + methodName
	ctx, end := span.StartWithName(ctx, spanName)
	defer func() {
		_ = span.Error(ctx, err)
		end()
	}()

	span.Attributes(ctx,
		semconv.CodeNamespace(pkgPath),
		semconv.CodeFunctionName(methodName),
		attribute.Key("code.type").String(typeName),
	)
	return _d.ExternalClient.Disconnect(ctx)
}

// Observe implements ExternalClient
func (_d InstrumentedExternalClient) Observe(ctx context.Context, mg resource.Managed) (e1 managed.ExternalObservation, err error) {
	t := reflect.TypeOf(_d.ExternalClient)
	var pkgPath, typeName string
	if t != nil {
		if t.Kind() == reflect.Ptr {
			t = t.Elem() // Dereference pointer to get underlying type
		}
		pkgPath = t.PkgPath()
		typeName = t.Name()
	}
	methodName := "Observe"
	spanName := pkgPath + "." + typeName + "." + methodName
	ctx, end := span.StartWithName(ctx, spanName)
	defer func() {
		_ = span.Error(ctx, err)
		end()
	}()

	span.Attributes(ctx,
		semconv.CodeNamespace(pkgPath),
		semconv.CodeFunctionName(methodName),
		attribute.Key("code.type").String(typeName),
	)
	return _d.ExternalClient.Observe(ctx, mg)
}

// Update implements ExternalClient
func (_d InstrumentedExternalClient) Update(ctx context.Context, mg resource.Managed) (e1 managed.ExternalUpdate, err error) {
	t := reflect.TypeOf(_d.ExternalClient)
	var pkgPath, typeName string
	if t != nil {
		if t.Kind() == reflect.Ptr {
			t = t.Elem() // Dereference pointer to get underlying type
		}
		pkgPath = t.PkgPath()
		typeName = t.Name()
	}
	methodName := "Update"
	spanName := pkgPath + "." + typeName + "." + methodName
	ctx, end := span.StartWithName(ctx, spanName)
	defer func() {
		_ = span.Error(ctx, err)
		end()
	}()

	span.Attributes(ctx,
		semconv.CodeNamespace(pkgPath),
		semconv.CodeFunctionName(methodName),
		attribute.Key("code.type").String(typeName),
	)
	return _d.ExternalClient.Update(ctx, mg)
}
