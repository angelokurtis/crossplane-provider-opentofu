// Code generated by gowrap. DO NOT EDIT.
// template: opentelemetry.gotmpl
// gowrap: http://github.com/hexdigest/gowrap

package otel

import (
	"context"
	"path"
	"reflect"

	"github.com/angelokurtis/go-otel/span"
	"github.com/upbound/provider-opentofu/internal/opentofu"
	. "github.com/upbound/provider-opentofu/internal/opentofu"
	"go.opentelemetry.io/otel/attribute"

	semconv "go.opentelemetry.io/otel/semconv/v1.30.0"
)

// InstrumentedOpenTofuClient implements OpenTofuClient interface instrumented with open telemetry spans
type InstrumentedOpenTofuClient struct {
	OpenTofuClient
}

// NewInstrumentedOpenTofuClient returns InstrumentedOpenTofuClient
func NewInstrumentedOpenTofuClient(base OpenTofuClient) InstrumentedOpenTofuClient {
	return InstrumentedOpenTofuClient{
		OpenTofuClient: base,
	}
}

// Apply implements OpenTofuClient
func (_d InstrumentedOpenTofuClient) Apply(ctx context.Context, o ...Option) (err error) {
	t := reflect.TypeOf(_d.OpenTofuClient)
	var pkgPath, pkgName, typeName string
	if t != nil {
		if t.Kind() == reflect.Ptr {
			t = t.Elem() // Dereference pointer to get underlying type
		}
		pkgPath = t.PkgPath()
		pkgName = path.Base(pkgPath)
		typeName = t.Name()
	}
	methodName := "Apply"
	spanName := pkgName + "." + typeName + "." + methodName
	ctx, end := span.StartWithName(ctx, spanName)
	defer func() {
		_ = span.Error(ctx, err)
		end()
	}()

	span.Attributes(ctx,
		semconv.CodeNamespace(pkgPath),
		semconv.CodeFunctionName(methodName),
		attribute.Key("code.type").String(typeName),
	)
	return _d.OpenTofuClient.Apply(ctx, o...)
}

// DeleteCurrentWorkspace implements OpenTofuClient
func (_d InstrumentedOpenTofuClient) DeleteCurrentWorkspace(ctx context.Context) (err error) {
	t := reflect.TypeOf(_d.OpenTofuClient)
	var pkgPath, pkgName, typeName string
	if t != nil {
		if t.Kind() == reflect.Ptr {
			t = t.Elem() // Dereference pointer to get underlying type
		}
		pkgPath = t.PkgPath()
		pkgName = path.Base(pkgPath)
		typeName = t.Name()
	}
	methodName := "DeleteCurrentWorkspace"
	spanName := pkgName + "." + typeName + "." + methodName
	ctx, end := span.StartWithName(ctx, spanName)
	defer func() {
		_ = span.Error(ctx, err)
		end()
	}()

	span.Attributes(ctx,
		semconv.CodeNamespace(pkgPath),
		semconv.CodeFunctionName(methodName),
		attribute.Key("code.type").String(typeName),
	)
	return _d.OpenTofuClient.DeleteCurrentWorkspace(ctx)
}

// Destroy implements OpenTofuClient
func (_d InstrumentedOpenTofuClient) Destroy(ctx context.Context, o ...Option) (err error) {
	t := reflect.TypeOf(_d.OpenTofuClient)
	var pkgPath, pkgName, typeName string
	if t != nil {
		if t.Kind() == reflect.Ptr {
			t = t.Elem() // Dereference pointer to get underlying type
		}
		pkgPath = t.PkgPath()
		pkgName = path.Base(pkgPath)
		typeName = t.Name()
	}
	methodName := "Destroy"
	spanName := pkgName + "." + typeName + "." + methodName
	ctx, end := span.StartWithName(ctx, spanName)
	defer func() {
		_ = span.Error(ctx, err)
		end()
	}()

	span.Attributes(ctx,
		semconv.CodeNamespace(pkgPath),
		semconv.CodeFunctionName(methodName),
		attribute.Key("code.type").String(typeName),
	)
	return _d.OpenTofuClient.Destroy(ctx, o...)
}

// Diff implements OpenTofuClient
func (_d InstrumentedOpenTofuClient) Diff(ctx context.Context, o ...Option) (b1 bool, err error) {
	t := reflect.TypeOf(_d.OpenTofuClient)
	var pkgPath, pkgName, typeName string
	if t != nil {
		if t.Kind() == reflect.Ptr {
			t = t.Elem() // Dereference pointer to get underlying type
		}
		pkgPath = t.PkgPath()
		pkgName = path.Base(pkgPath)
		typeName = t.Name()
	}
	methodName := "Diff"
	spanName := pkgName + "." + typeName + "." + methodName
	ctx, end := span.StartWithName(ctx, spanName)
	defer func() {
		_ = span.Error(ctx, err)
		end()
	}()

	span.Attributes(ctx,
		semconv.CodeNamespace(pkgPath),
		semconv.CodeFunctionName(methodName),
		attribute.Key("code.type").String(typeName),
	)
	return _d.OpenTofuClient.Diff(ctx, o...)
}

// GenerateChecksum implements OpenTofuClient
func (_d InstrumentedOpenTofuClient) GenerateChecksum(ctx context.Context) (s1 string, err error) {
	t := reflect.TypeOf(_d.OpenTofuClient)
	var pkgPath, pkgName, typeName string
	if t != nil {
		if t.Kind() == reflect.Ptr {
			t = t.Elem() // Dereference pointer to get underlying type
		}
		pkgPath = t.PkgPath()
		pkgName = path.Base(pkgPath)
		typeName = t.Name()
	}
	methodName := "GenerateChecksum"
	spanName := pkgName + "." + typeName + "." + methodName
	ctx, end := span.StartWithName(ctx, spanName)
	defer func() {
		_ = span.Error(ctx, err)
		end()
	}()

	span.Attributes(ctx,
		semconv.CodeNamespace(pkgPath),
		semconv.CodeFunctionName(methodName),
		attribute.Key("code.type").String(typeName),
	)
	return _d.OpenTofuClient.GenerateChecksum(ctx)
}

// Init implements OpenTofuClient
func (_d InstrumentedOpenTofuClient) Init(ctx context.Context, o ...InitOption) (err error) {
	t := reflect.TypeOf(_d.OpenTofuClient)
	var pkgPath, pkgName, typeName string
	if t != nil {
		if t.Kind() == reflect.Ptr {
			t = t.Elem() // Dereference pointer to get underlying type
		}
		pkgPath = t.PkgPath()
		pkgName = path.Base(pkgPath)
		typeName = t.Name()
	}
	methodName := "Init"
	spanName := pkgName + "." + typeName + "." + methodName
	ctx, end := span.StartWithName(ctx, spanName)
	defer func() {
		_ = span.Error(ctx, err)
		end()
	}()

	span.Attributes(ctx,
		semconv.CodeNamespace(pkgPath),
		semconv.CodeFunctionName(methodName),
		attribute.Key("code.type").String(typeName),
	)
	return _d.OpenTofuClient.Init(ctx, o...)
}

// Outputs implements OpenTofuClient
func (_d InstrumentedOpenTofuClient) Outputs(ctx context.Context) (oa1 []opentofu.Output, err error) {
	t := reflect.TypeOf(_d.OpenTofuClient)
	var pkgPath, pkgName, typeName string
	if t != nil {
		if t.Kind() == reflect.Ptr {
			t = t.Elem() // Dereference pointer to get underlying type
		}
		pkgPath = t.PkgPath()
		pkgName = path.Base(pkgPath)
		typeName = t.Name()
	}
	methodName := "Outputs"
	spanName := pkgName + "." + typeName + "." + methodName
	ctx, end := span.StartWithName(ctx, spanName)
	defer func() {
		_ = span.Error(ctx, err)
		end()
	}()

	span.Attributes(ctx,
		semconv.CodeNamespace(pkgPath),
		semconv.CodeFunctionName(methodName),
		attribute.Key("code.type").String(typeName),
	)
	return _d.OpenTofuClient.Outputs(ctx)
}

// Resources implements OpenTofuClient
func (_d InstrumentedOpenTofuClient) Resources(ctx context.Context) (sa1 []string, err error) {
	t := reflect.TypeOf(_d.OpenTofuClient)
	var pkgPath, pkgName, typeName string
	if t != nil {
		if t.Kind() == reflect.Ptr {
			t = t.Elem() // Dereference pointer to get underlying type
		}
		pkgPath = t.PkgPath()
		pkgName = path.Base(pkgPath)
		typeName = t.Name()
	}
	methodName := "Resources"
	spanName := pkgName + "." + typeName + "." + methodName
	ctx, end := span.StartWithName(ctx, spanName)
	defer func() {
		_ = span.Error(ctx, err)
		end()
	}()

	span.Attributes(ctx,
		semconv.CodeNamespace(pkgPath),
		semconv.CodeFunctionName(methodName),
		attribute.Key("code.type").String(typeName),
	)
	return _d.OpenTofuClient.Resources(ctx)
}

// Validate implements OpenTofuClient
func (_d InstrumentedOpenTofuClient) Validate(ctx context.Context) (err error) {
	t := reflect.TypeOf(_d.OpenTofuClient)
	var pkgPath, pkgName, typeName string
	if t != nil {
		if t.Kind() == reflect.Ptr {
			t = t.Elem() // Dereference pointer to get underlying type
		}
		pkgPath = t.PkgPath()
		pkgName = path.Base(pkgPath)
		typeName = t.Name()
	}
	methodName := "Validate"
	spanName := pkgName + "." + typeName + "." + methodName
	ctx, end := span.StartWithName(ctx, spanName)
	defer func() {
		_ = span.Error(ctx, err)
		end()
	}()

	span.Attributes(ctx,
		semconv.CodeNamespace(pkgPath),
		semconv.CodeFunctionName(methodName),
		attribute.Key("code.type").String(typeName),
	)
	return _d.OpenTofuClient.Validate(ctx)
}

// Workspace implements OpenTofuClient
func (_d InstrumentedOpenTofuClient) Workspace(ctx context.Context, name string) (err error) {
	t := reflect.TypeOf(_d.OpenTofuClient)
	var pkgPath, pkgName, typeName string
	if t != nil {
		if t.Kind() == reflect.Ptr {
			t = t.Elem() // Dereference pointer to get underlying type
		}
		pkgPath = t.PkgPath()
		pkgName = path.Base(pkgPath)
		typeName = t.Name()
	}
	methodName := "Workspace"
	spanName := pkgName + "." + typeName + "." + methodName
	ctx, end := span.StartWithName(ctx, spanName)
	defer func() {
		_ = span.Error(ctx, err)
		end()
	}()

	span.Attributes(ctx,
		semconv.CodeNamespace(pkgPath),
		semconv.CodeFunctionName(methodName),
		attribute.Key("code.type").String(typeName),
	)
	return _d.OpenTofuClient.Workspace(ctx, name)
}
